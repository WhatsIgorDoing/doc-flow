============================= test session starts =============================
platform win32 -- Python 3.11.3, pytest-7.4.4, pluggy-1.6.0
rootdir: C:\Development\doc-flow
plugins: anyio-4.12.0, asyncio-0.23.3, cov-7.0.0, mock-3.15.1, timeout-2.4.0
asyncio: mode=Mode.STRICT
collected 3 items

tests\unit\infrastructure\test_database.py EEE                           [100%]

=================================== ERRORS ====================================
___________ ERROR at setup of test_save_and_get_validated_documents ___________

tmp_path = WindowsPath('C:/Users/igor.bueno/AppData/Local/Temp/pytest-of-igor.bueno/pytest-35/test_save_and_get_validated_do0')

    @pytest.fixture
    def db_manager(tmp_path):
        # Sobrescreve database path para usar arquivo temporario ou memoria
        # Mas como DatabaseManager usa settings singleton, vamos usar :memory: se possivel
        # ou monkeypatch settings.
    
        from app.core.config import settings
    
        # Use um arquivo unico no tmp_path para evitar conflitos
        test_db = tmp_path / "test_docflow.db"
    
        # Importante: DatabaseManager Ú singleton. Precisamos reinicializar ou usar uma instancia nova
        # Mas o codigo usa o singleton global importado.
    
        # Hack: Patch get_database_path do settings object
        with pytest.MonkeyPatch.context() as m:
>           m.setattr(settings, "get_database_path", lambda: test_db)

tests\unit\infrastructure\test_database.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Settings(APP_NAME='SAD_Validator', APP_VERSION='2.0.0', ENVIRONMENT='development', DEBUG=False, SECRET_KEY='03jnMMygCp...=3, SYNC_ENABLED=True, LOG_LEVEL='INFO', LOG_PATH='./logs', LOG_FORMAT='json', HOST='0.0.0.0', PORT=8080, RELOAD=False)
name = 'get_database_path'
value = <function db_manager.<locals>.<lambda> at 0x000002536D8AEF20>

    def __setattr__(self, name: str, value: Any) -> None:
        if name in self.__class_vars__:
            raise AttributeError(
                f'{name!r} is a ClassVar of `{self.__class__.__name__}` and cannot be set on an instance. '
                f'If you want to set a value on the class, use `{self.__class__.__name__}.{name} = value`.'
            )
        elif not _fields.is_valid_field_name(name):
            if self.__pydantic_private__ is None or name not in self.__private_attributes__:
                _object_setattr(self, name, value)
            else:
                attribute = self.__private_attributes__[name]
                if hasattr(attribute, '__set__'):
                    attribute.__set__(self, value)  # type: ignore
                else:
                    self.__pydantic_private__[name] = value
            return
    
        self._check_frozen(name, value)
    
        attr = getattr(self.__class__, name, None)
        if isinstance(attr, property):
            attr.__set__(self, value)
        elif self.model_config.get('validate_assignment', None):
            self.__pydantic_validator__.validate_assignment(self, name, value)
        elif self.model_config.get('extra') != 'allow' and name not in self.model_fields:
            # TODO - matching error
>           raise ValueError(f'"{self.__class__.__name__}" object has no field "{name}"')
E           ValueError: "Settings" object has no field "get_database_path"

C:\Users\igor.bueno\AppData\Roaming\Python\Python311\site-packages\pydantic\main.py:789: ValueError

During handling of the above exception, another exception occurred:

tmp_path = WindowsPath('C:/Users/igor.bueno/AppData/Local/Temp/pytest-of-igor.bueno/pytest-35/test_save_and_get_validated_do0')

    @pytest.fixture
    def db_manager(tmp_path):
        # Sobrescreve database path para usar arquivo temporario ou memoria
        # Mas como DatabaseManager usa settings singleton, vamos usar :memory: se possivel
        # ou monkeypatch settings.
    
        from app.core.config import settings
    
        # Use um arquivo unico no tmp_path para evitar conflitos
        test_db = tmp_path / "test_docflow.db"
    
        # Importante: DatabaseManager Ú singleton. Precisamos reinicializar ou usar uma instancia nova
        # Mas o codigo usa o singleton global importado.
    
        # Hack: Patch get_database_path do settings object
>       with pytest.MonkeyPatch.context() as m:

tests\unit\infrastructure\test_database.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\contextlib.py:155: in __exit__
    self.gen.throw(typ, value, traceback)
C:\Users\igor.bueno\AppData\Roaming\Python\Python311\site-packages\_pytest\monkeypatch.py:162: in context
    m.undo()
C:\Users\igor.bueno\AppData\Roaming\Python\Python311\site-packages\_pytest\monkeypatch.py:400: in undo
    setattr(obj, name, value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Settings(APP_NAME='SAD_Validator', APP_VERSION='2.0.0', ENVIRONMENT='development', DEBUG=False, SECRET_KEY='03jnMMygCp...=3, SYNC_ENABLED=True, LOG_LEVEL='INFO', LOG_PATH='./logs', LOG_FORMAT='json', HOST='0.0.0.0', PORT=8080, RELOAD=False)
name = 'get_database_path'
value = <bound method Settings.get_database_path of Settings(APP_NAME='SAD_Validator', APP_VERSION='2.0.0', ENVIRONMENT='devel...3, SYNC_ENABLED=True, LOG_LEVEL='INFO', LOG_PATH='./logs', LOG_FORMAT='json', HOST='0.0.0.0', PORT=8080, RELOAD=False)>

    def __setattr__(self, name: str, value: Any) -> None:
        if name in self.__class_vars__:
            raise AttributeError(
                f'{name!r} is a ClassVar of `{self.__class__.__name__}` and cannot be set on an instance. '
                f'If you want to set a value on the class, use `{self.__class__.__name__}.{name} = value`.'
            )
        elif not _fields.is_valid_field_name(name):
            if self.__pydantic_private__ is None or name not in self.__private_attributes__:
                _object_setattr(self, name, value)
            else:
                attribute = self.__private_attributes__[name]
                if hasattr(attribute, '__set__'):
                    attribute.__set__(self, value)  # type: ignore
                else:
                    self.__pydantic_private__[name] = value
            return
    
        self._check_frozen(name, value)
    
        attr = getattr(self.__class__, name, None)
        if isinstance(attr, property):
            attr.__set__(self, value)
        elif self.model_config.get('validate_assignment', None):
            self.__pydantic_validator__.validate_assignment(self, name, value)
        elif self.model_config.get('extra') != 'allow' and name not in self.model_fields:
            # TODO - matching error
>           raise ValueError(f'"{self.__class__.__name__}" object has no field "{name}"')
E           ValueError: "Settings" object has no field "get_database_path"

C:\Users\igor.bueno\AppData\Roaming\Python\Python311\site-packages\pydantic\main.py:789: ValueError
______________ ERROR at setup of test_clear_validated_documents _______________

tmp_path = WindowsPath('C:/Users/igor.bueno/AppData/Local/Temp/pytest-of-igor.bueno/pytest-35/test_clear_validated_documents0')

    @pytest.fixture
    def db_manager(tmp_path):
        # Sobrescreve database path para usar arquivo temporario ou memoria
        # Mas como DatabaseManager usa settings singleton, vamos usar :memory: se possivel
        # ou monkeypatch settings.
    
        from app.core.config import settings
    
        # Use um arquivo unico no tmp_path para evitar conflitos
        test_db = tmp_path / "test_docflow.db"
    
        # Importante: DatabaseManager Ú singleton. Precisamos reinicializar ou usar uma instancia nova
        # Mas o codigo usa o singleton global importado.
    
        # Hack: Patch get_database_path do settings object
        with pytest.MonkeyPatch.context() as m:
>           m.setattr(settings, "get_database_path", lambda: test_db)

tests\unit\infrastructure\test_database.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Settings(APP_NAME='SAD_Validator', APP_VERSION='2.0.0', ENVIRONMENT='development', DEBUG=False, SECRET_KEY='03jnMMygCp...=3, SYNC_ENABLED=True, LOG_LEVEL='INFO', LOG_PATH='./logs', LOG_FORMAT='json', HOST='0.0.0.0', PORT=8080, RELOAD=False)
name = 'get_database_path'
value = <function db_manager.<locals>.<lambda> at 0x000002536DACC040>

    def __setattr__(self, name: str, value: Any) -> None:
        if name in self.__class_vars__:
            raise AttributeError(
                f'{name!r} is a ClassVar of `{self.__class__.__name__}` and cannot be set on an instance. '
                f'If you want to set a value on the class, use `{self.__class__.__name__}.{name} = value`.'
            )
        elif not _fields.is_valid_field_name(name):
            if self.__pydantic_private__ is None or name not in self.__private_attributes__:
                _object_setattr(self, name, value)
            else:
                attribute = self.__private_attributes__[name]
                if hasattr(attribute, '__set__'):
                    attribute.__set__(self, value)  # type: ignore
                else:
                    self.__pydantic_private__[name] = value
            return
    
        self._check_frozen(name, value)
    
        attr = getattr(self.__class__, name, None)
        if isinstance(attr, property):
            attr.__set__(self, value)
        elif self.model_config.get('validate_assignment', None):
            self.__pydantic_validator__.validate_assignment(self, name, value)
        elif self.model_config.get('extra') != 'allow' and name not in self.model_fields:
            # TODO - matching error
>           raise ValueError(f'"{self.__class__.__name__}" object has no field "{name}"')
E           ValueError: "Settings" object has no field "get_database_path"

C:\Users\igor.bueno\AppData\Roaming\Python\Python311\site-packages\pydantic\main.py:789: ValueError

During handling of the above exception, another exception occurred:

tmp_path = WindowsPath('C:/Users/igor.bueno/AppData/Local/Temp/pytest-of-igor.bueno/pytest-35/test_clear_validated_documents0')

    @pytest.fixture
    def db_manager(tmp_path):
        # Sobrescreve database path para usar arquivo temporario ou memoria
        # Mas como DatabaseManager usa settings singleton, vamos usar :memory: se possivel
        # ou monkeypatch settings.
    
        from app.core.config import settings
    
        # Use um arquivo unico no tmp_path para evitar conflitos
        test_db = tmp_path / "test_docflow.db"
    
        # Importante: DatabaseManager Ú singleton. Precisamos reinicializar ou usar uma instancia nova
        # Mas o codigo usa o singleton global importado.
    
        # Hack: Patch get_database_path do settings object
>       with pytest.MonkeyPatch.context() as m:

tests\unit\infrastructure\test_database.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\contextlib.py:155: in __exit__
    self.gen.throw(typ, value, traceback)
C:\Users\igor.bueno\AppData\Roaming\Python\Python311\site-packages\_pytest\monkeypatch.py:162: in context
    m.undo()
C:\Users\igor.bueno\AppData\Roaming\Python\Python311\site-packages\_pytest\monkeypatch.py:400: in undo
    setattr(obj, name, value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Settings(APP_NAME='SAD_Validator', APP_VERSION='2.0.0', ENVIRONMENT='development', DEBUG=False, SECRET_KEY='03jnMMygCp...=3, SYNC_ENABLED=True, LOG_LEVEL='INFO', LOG_PATH='./logs', LOG_FORMAT='json', HOST='0.0.0.0', PORT=8080, RELOAD=False)
name = 'get_database_path'
value = <bound method Settings.get_database_path of Settings(APP_NAME='SAD_Validator', APP_VERSION='2.0.0', ENVIRONMENT='devel...3, SYNC_ENABLED=True, LOG_LEVEL='INFO', LOG_PATH='./logs', LOG_FORMAT='json', HOST='0.0.0.0', PORT=8080, RELOAD=False)>

    def __setattr__(self, name: str, value: Any) -> None:
        if name in self.__class_vars__:
            raise AttributeError(
                f'{name!r} is a ClassVar of `{self.__class__.__name__}` and cannot be set on an instance. '
                f'If you want to set a value on the class, use `{self.__class__.__name__}.{name} = value`.'
            )
        elif not _fields.is_valid_field_name(name):
            if self.__pydantic_private__ is None or name not in self.__private_attributes__:
                _object_setattr(self, name, value)
            else:
                attribute = self.__private_attributes__[name]
                if hasattr(attribute, '__set__'):
                    attribute.__set__(self, value)  # type: ignore
                else:
                    self.__pydantic_private__[name] = value
            return
    
        self._check_frozen(name, value)
    
        attr = getattr(self.__class__, name, None)
        if isinstance(attr, property):
            attr.__set__(self, value)
        elif self.model_config.get('validate_assignment', None):
            self.__pydantic_validator__.validate_assignment(self, name, value)
        elif self.model_config.get('extra') != 'allow' and name not in self.model_fields:
            # TODO - matching error
>           raise ValueError(f'"{self.__class__.__name__}" object has no field "{name}"')
E           ValueError: "Settings" object has no field "get_database_path"

C:\Users\igor.bueno\AppData\Roaming\Python\Python311\site-packages\pydantic\main.py:789: ValueError
________ ERROR at setup of test_save_overwrites_previous_session_data _________

tmp_path = WindowsPath('C:/Users/igor.bueno/AppData/Local/Temp/pytest-of-igor.bueno/pytest-35/test_save_overwrites_previous_0')

    @pytest.fixture
    def db_manager(tmp_path):
        # Sobrescreve database path para usar arquivo temporario ou memoria
        # Mas como DatabaseManager usa settings singleton, vamos usar :memory: se possivel
        # ou monkeypatch settings.
    
        from app.core.config import settings
    
        # Use um arquivo unico no tmp_path para evitar conflitos
        test_db = tmp_path / "test_docflow.db"
    
        # Importante: DatabaseManager Ú singleton. Precisamos reinicializar ou usar uma instancia nova
        # Mas o codigo usa o singleton global importado.
    
        # Hack: Patch get_database_path do settings object
        with pytest.MonkeyPatch.context() as m:
>           m.setattr(settings, "get_database_path", lambda: test_db)

tests\unit\infrastructure\test_database.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Settings(APP_NAME='SAD_Validator', APP_VERSION='2.0.0', ENVIRONMENT='development', DEBUG=False, SECRET_KEY='03jnMMygCp...=3, SYNC_ENABLED=True, LOG_LEVEL='INFO', LOG_PATH='./logs', LOG_FORMAT='json', HOST='0.0.0.0', PORT=8080, RELOAD=False)
name = 'get_database_path'
value = <function db_manager.<locals>.<lambda> at 0x000002536D8AED40>

    def __setattr__(self, name: str, value: Any) -> None:
        if name in self.__class_vars__:
            raise AttributeError(
                f'{name!r} is a ClassVar of `{self.__class__.__name__}` and cannot be set on an instance. '
                f'If you want to set a value on the class, use `{self.__class__.__name__}.{name} = value`.'
            )
        elif not _fields.is_valid_field_name(name):
            if self.__pydantic_private__ is None or name not in self.__private_attributes__:
                _object_setattr(self, name, value)
            else:
                attribute = self.__private_attributes__[name]
                if hasattr(attribute, '__set__'):
                    attribute.__set__(self, value)  # type: ignore
                else:
                    self.__pydantic_private__[name] = value
            return
    
        self._check_frozen(name, value)
    
        attr = getattr(self.__class__, name, None)
        if isinstance(attr, property):
            attr.__set__(self, value)
        elif self.model_config.get('validate_assignment', None):
            self.__pydantic_validator__.validate_assignment(self, name, value)
        elif self.model_config.get('extra') != 'allow' and name not in self.model_fields:
            # TODO - matching error
>           raise ValueError(f'"{self.__class__.__name__}" object has no field "{name}"')
E           ValueError: "Settings" object has no field "get_database_path"

C:\Users\igor.bueno\AppData\Roaming\Python\Python311\site-packages\pydantic\main.py:789: ValueError

During handling of the above exception, another exception occurred:

tmp_path = WindowsPath('C:/Users/igor.bueno/AppData/Local/Temp/pytest-of-igor.bueno/pytest-35/test_save_overwrites_previous_0')

    @pytest.fixture
    def db_manager(tmp_path):
        # Sobrescreve database path para usar arquivo temporario ou memoria
        # Mas como DatabaseManager usa settings singleton, vamos usar :memory: se possivel
        # ou monkeypatch settings.
    
        from app.core.config import settings
    
        # Use um arquivo unico no tmp_path para evitar conflitos
        test_db = tmp_path / "test_docflow.db"
    
        # Importante: DatabaseManager Ú singleton. Precisamos reinicializar ou usar uma instancia nova
        # Mas o codigo usa o singleton global importado.
    
        # Hack: Patch get_database_path do settings object
>       with pytest.MonkeyPatch.context() as m:

tests\unit\infrastructure\test_database.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\contextlib.py:155: in __exit__
    self.gen.throw(typ, value, traceback)
C:\Users\igor.bueno\AppData\Roaming\Python\Python311\site-packages\_pytest\monkeypatch.py:162: in context
    m.undo()
C:\Users\igor.bueno\AppData\Roaming\Python\Python311\site-packages\_pytest\monkeypatch.py:400: in undo
    setattr(obj, name, value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Settings(APP_NAME='SAD_Validator', APP_VERSION='2.0.0', ENVIRONMENT='development', DEBUG=False, SECRET_KEY='03jnMMygCp...=3, SYNC_ENABLED=True, LOG_LEVEL='INFO', LOG_PATH='./logs', LOG_FORMAT='json', HOST='0.0.0.0', PORT=8080, RELOAD=False)
name = 'get_database_path'
value = <bound method Settings.get_database_path of Settings(APP_NAME='SAD_Validator', APP_VERSION='2.0.0', ENVIRONMENT='devel...3, SYNC_ENABLED=True, LOG_LEVEL='INFO', LOG_PATH='./logs', LOG_FORMAT='json', HOST='0.0.0.0', PORT=8080, RELOAD=False)>

    def __setattr__(self, name: str, value: Any) -> None:
        if name in self.__class_vars__:
            raise AttributeError(
                f'{name!r} is a ClassVar of `{self.__class__.__name__}` and cannot be set on an instance. '
                f'If you want to set a value on the class, use `{self.__class__.__name__}.{name} = value`.'
            )
        elif not _fields.is_valid_field_name(name):
            if self.__pydantic_private__ is None or name not in self.__private_attributes__:
                _object_setattr(self, name, value)
            else:
                attribute = self.__private_attributes__[name]
                if hasattr(attribute, '__set__'):
                    attribute.__set__(self, value)  # type: ignore
                else:
                    self.__pydantic_private__[name] = value
            return
    
        self._check_frozen(name, value)
    
        attr = getattr(self.__class__, name, None)
        if isinstance(attr, property):
            attr.__set__(self, value)
        elif self.model_config.get('validate_assignment', None):
            self.__pydantic_validator__.validate_assignment(self, name, value)
        elif self.model_config.get('extra') != 'allow' and name not in self.model_fields:
            # TODO - matching error
>           raise ValueError(f'"{self.__class__.__name__}" object has no field "{name}"')
E           ValueError: "Settings" object has no field "get_database_path"

C:\Users\igor.bueno\AppData\Roaming\Python\Python311\site-packages\pydantic\main.py:789: ValueError
=========================== short test summary info ===========================
ERROR tests/unit/infrastructure/test_database.py::test_save_and_get_validated_documents
ERROR tests/unit/infrastructure/test_database.py::test_clear_validated_documents
ERROR tests/unit/infrastructure/test_database.py::test_save_overwrites_previous_session_data
============================== 3 errors in 1.30s ==============================
